#!/usr/bin/env node
// @ts-check

// This will get all the hashes from `./hack/update` and generate a `systems.nix`
// file in the root directory.
//
// Rather not do this whole thing in bash, sorry.

import { readFile, writeFile } from 'node:fs/promises';
import { execSync } from 'node:child_process';
import { join } from 'node:path';
import { exit } from 'node:process';

/** @type {Array<{hash:string; uri:string; system:string;}>} */
const hashes = [];

/**
 * Returns a Nix-compatible system name for `build`
 * @param {string} build
 * @returns {string}
 */
function getNixSystemForBuild(build) {
    switch (build) {
        case 'linux-x64': return 'x86_64-linux';
        case 'linux-arm64': return 'aarch64-linux';
        case 'linux-armhf': return 'armv7l-linux';
        case 'darwin': return 'x86_64-darwin';
        case 'darwin-arm64': return 'aarch64-darwin';
        default:
            throw new Error(`unknown build: ${build}`);
    }
}

const filepath = join(process.cwd(), 'systems.nix');
const fileContents = await readFile(filepath).then(file => file.toString('utf-8'));

for (const build of ["linux-x64", "linux-arm64", "linux-armhf", "darwin", "darwin-arm64"]) {
    console.log(`getting hashes for build: ${build}`);

    const url = `https://update.code.visualstudio.com/latest/${build}/insider`;
    const location = await fetch(url).then(res => res.url);

    if (location === null) {
        console.log(`invalid uri: ${url}`);
        exit(1);
    }

    if (fileContents.includes(`url = "${location}";`)) {
        console.warn(`warn: build ${build} already has generated hashes, do not attempt again`);
        continue;
    }

    console.log(`url for build ${build}: ${location}`);

    // Prefetch the URL into the Nix store (so that it'll be easier for us)
    console.log(`generating hashes for build ${build}...`);

    const { hash, storePath } = JSON.parse(execSync(`nix flake prefetch --extra-experimental-features 'nix-command flakes' --json "${location}"`).toString('utf-8'));
    console.log(`build ${build} hash: ${hash} (${storePath})`);

    hashes.push({
        hash,
        uri: location,
        system: getNixSystemForBuild(build)
    });
}

if (Object.keys(hashes).length === 0) {
    console.warn('warn: all hashes are up to date!');
    exit(1);
}

const systems = [
    '# this file was generated by the ./hack/generateSystems.js script',
    '# do not edit this file as it\'ll most likely be overwritten on next invocation',
    '',
    '{fetchzip}: {',
];

for (const { hash, uri, system } of hashes) {
    systems.push(`  ${system} = fetchzip {`);
    systems.push(`    url = "${uri}";`);
    systems.push(`    hash = "${hash}";`);
    systems.push('  };');
}

systems.push('}');

const file = systems.join('\n');

console.log('generated `systems.nix`:\n', file);
await writeFile(filepath, file);

console.log('formatting file with `nix fmt`');
execSync(`nix fmt "${filepath}"`);
